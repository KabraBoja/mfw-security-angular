!function(){"use strict";function a(){this.$get=["$log","$rootScope","$timeout","$mfwSecurityRouteInterceptorConfig","$mfwSecurity","$state","$mfwSecurityConfig",function(a,b,e,f,g,h,i){function j(){k(),z=f.defaultState,y=q(),b.$on("$stateChangeStart",l),b.$on("$stateChangeError",m),b.$on(i.EVENT_LOGIN,n),b.$on(i.EVENT_LOGOUT,o)}function k(){function b(b){a.error("Configuration error:",b)}f.avoidLoginStateWhenLoggedIn===!0&&angular.isUndefined(f.defaultState)&&b("avoidLoginStateWhenLoggedIn=true, defaultState=undefined"),f.forwardToDefaultStateAfterLogin===!0&&angular.isUndefined(f.defaultState)&&b("forwardToDefaultStateAfterLogin=true, defaultState=undefined")}function l(b,c,d){function h(){b.preventDefault()}var i=g.isLogged();r(c)&&i&&f.avoidLoginStateWhenLoggedIn===!0?z?(a.debug("Stopping transition to login state as user is already logged in. Will be redirected to default state",z),h(),e(function(){x(z)})):a.error("Tried to avoid login state for a logged user, but no default state is configured."):t(c,d)?a.debug("Has access to state, continue with state change event."):(a.warn("Stopping transition to state",c.name),h(),v(),f.forwardToLoginAfterStoppedTransition===!0&&x(y))}function m(b,c,d,e,g,h){401===h.status&&(a.error("State change due to 401 server response. Perform logout."),f.forwardToRestrictedStateAfterLogin===!0&&(A=c,B=d),p())}function n(){function b(){f.forwardToDefaultStateAfterLogin===!0&&z&&(a.debug("Transition to default state after login:",z),x(z))}A?(f.forwardToRestrictedStateAfterLogin===!0?(a.log("Redirecting to login state after logout."),x(A,B)):b(),A=null):b()}function o(){f.forwardToLoginAfterLogout===!0&&(y?(a.log("Redirecting to login state after logout."),x(y)):a.warn("There's no configured login state to be redirected after logout."))}function p(){g.logout()}function q(){var b,c=f.loginState;angular.isDefined(c)&&(a.debug("Configured in constants the login state",c),b=h.get(c),b||a.warn("There's no state with name",c));var d=h.get().filter(r);if(d.length>1)throw new Error("More than one state is tagged as login.");if(1===d.length){var e=d[0];b?a.debug("Overriding login state with ",e.name):a.debug("Found login state",e.name),b=e}return b||a.warn("There's no state tagged as login state."),b}function r(a){var b=s(a);return b.login===!0||a.name===f.loginState}function s(a){var b=a.data||{};return c&&(b=b[c]||{}),b}function t(b,c){var d=s(b),e=d.permissions,h=g.isLogged(),i=!0;return u(b)?(a.debug("Public access to state",b.name),i=!0):e?angular.isString(e)||angular.isArray(e)?i=g.hasAnyPermission(e):angular.isObject(e)?e.all?i=g.hasAllPermissions(e.all):e.any?i=g.hasAnyPermission(e.any):a.warn("Unkown permissions setting in state",b.name):a.warn("Unkown permissions setting in state",b.name):f.publicByDefault!==!0?(a.debug("State",b.name,"has no permissions defined, and setting publicByDefault is set to false."),i=h,h?a.debug("User is logged in so he has access to state",b.name):a.debug("User is not logged in so he has no access to state",b.name)):(a.debug("State",b.name,"has no permissions defined, and setting publicByDefault is set to true."),i=!0),i}function u(a){var b=s(a),c=b.permissions;return b["public"]===!0||r(a)||(!c||!c.length)&&f.publicByDefault}function v(){w(d)}function w(a,c){b.$broadcast(a,c)}function x(a,b){h.go(a,b)}var y,z,A,B,C={init:j};return C}]}var b=angular.module("mfw.security.route-interceptor.uirouter",["mfw.security","ui.router"]);b.run(["$mfwSecurityRouteInterceptor",function(a){a.init()}]);var c=null,d="$mfwSecurityStateTransitionStopped";b.constant("$mfwSecurityRouteInterceptorConfig",{publicByDefault:!0,loginState:void 0,defaultState:void 0,forwardToDefaultStateAfterLogin:!1,forwardToLoginAfterLogout:!0,forwardToRestrictedStateAfterLogin:!1,forwardToLoginAfterStoppedTransition:!1,avoidLoginStateWhenLoggedIn:!0}),b.provider("$mfwSecurityRouteInterceptor",a)}();
//# sourceMappingURL=mfw-security-route-interceptor-uirouter.service.min.js.map